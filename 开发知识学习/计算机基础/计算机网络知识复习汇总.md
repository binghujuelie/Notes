# 计算机网络面试知识复习汇总

> 转载声明：
>
> 本文原创作者：
>
> ​	[书呆子Rico](http://my.csdn.net/justloveyou_) 
>
> ​	[追逐更好的自己](https://www.cnblogs.com/inception6-lxc/)
> 作者博客地址：
>
> ​	<http://blog.csdn.net/justloveyou_/> 
>
> ​	<https://www.cnblogs.com/inception6-lxc/p/9152691.html>



[TOC]

## HTTP和HTTPs的区别

HTTP协议运行在TCP上，使用明文传输，客户端与服务器都无法验证对方的身份；

HTTPs是有SSL(Secure Socket Layer)外壳的HTTP，运行于SSL上，SSL运行在TCP上，是添加了加密和认证机制的HTTP协议。

不同体现在以下几方面：

- 端口不同：HTTP使用80端口；HTTPs使用443端口。
- 资源消耗：HTTPs由于需要进行加解密处理而消耗更多的CPU和内存资源。
- 开销：HTTPs通信需要证书，需要向相关机构购买。

> HTTPs加密机制是一种共享密钥和公开密钥加密并用的混合加密机制。

## 对称加密与非对称加密

- 对称加密：加密和解密使用同一个密钥。最大问题是如何将密钥安全地发送给对方。
- 非对称加密：发送方使用公钥进行加密，接收方使用私钥进行解密。公钥可以随意发布，而私钥只有自己知道。

> 由于非对称加密不需要发送用于解密的私钥，可以保证其安全性。但是非对称加密与对称加密相比效率很低，所以还是用对称加密来发送信息，而用于解密的密钥可以使用非对称加密的方式发送出去。

## 三次握手与四次挥手

### 三次握手

> 我要和你建立连接——你真的要和我建立链接吗——我真的要和你建立连接——建立成功

- 第一次握手：Client将标志位`SYN`置为`1`，随机产生一个值`seq=J`，并将该数据包发送给Server，Client进入`SYN_SENT`状态，等待Server确认。
- 第二次握手：Server收到数据包后由标志位`SYN=1`知道Client请求建立连接，Server将标志位`SYN`和`ACK`都置为`1`，`ack=J+1`，随机产生一个值`seq=K`，并将该数据包发送给Client以确认连接请求，Server进入`SYN_RCVD`状态。
- 第三次握手：Client收到确认后，检查`ack`是否为`J+1`，`ACK`是否为`1`，如果正确则将标志位`ACK`置为`1`，`ack=K+1`，并将该数据包发送给Server，Server检查`ack`是否为`K+1`，`ACK`是否为`1`，如果正确则连接建立成功，Client和Server进入`ESTABLISHED`状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

![三次握手](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e92d0ebc-7d46-413b-aec1-34a39602f787.png)

### 四次挥手

> 我要和你断开连接——好的，断开吧。我也要和你断开连接——好的，断开吧

- 第一次挥手：Client发送一个`FIN`，**用来关闭Client到Server的数据传送**，Client进入`FIN_WAIT_1`状态。
- 第二次挥手：Server收到`FIN`后，发送一个`ACK`给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入`CLOSE_WAIT`状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。
- 第三次挥手：Server发送一个`FIN`，**用来关闭Server到Client的数据传送**，Server进入`LAST_ACK`状态。
- 第四次挥手：Client收到`FIN`后，Client进入`TIME_WAIT`状态，接着发送一个`ACK`给Server，确认序号为收到序号+1，Server进入`CLOSED`状态，完成四次挥手。

![四次挥手](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg)

## 为什么TCP建立连接需要三次握手？为什么不可以两次？

​	为了防止**已失效的连接请求报文又传送到了服务端**，因而产生错误。

​	客户端发出的连接请求报文并未丢失，而是在某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间才到达Server。这时，Server误以为这是Client发出的一个新的链接请求，于是就向客户端发送确认数据包，同意建立链接。若不采用“三次握手”，那么只要Server发出确认数据包，新的链接就建立了。由于client此时并未发出建立链接的请求，所以其不会理睬Server的确认，也不与Server通信；而这时Server一直在等待Client的请求，这样Server就白白浪费了一定的资源。若采用“三次握手”，在这种情况下，由于Server端没有收到来自客户端的确认，则就会知道Client并没有要求建立请求，就不会建立链接。

## TCP协议如何保证数据传输的可靠性

TCP提供一种面向连接的、可靠的字节流服务。其中：

- 面向连接：意味着两个使用TCP的应用（通常是C-S）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有双方进行彼此通信。
- 字节流服务：意味着两个应用程序通过TCP连接交换`8bit`字节构成的字节流，TCP不在字节流中插入记录标识符。

**TCP协议通过以下方式来保证传输可靠性：**

- **数据包校验**：为了检测数据在传输过程中的任何变化，若校验包出错，则丢弃报文段且不作出回应，这时TCP的发送端超时后会重传数据。

- **对失序数据包进行重排序**：TCP报文段作为IP数据报进行传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将失序数据进行重排序后才提交给应用层。

- **丢弃重复数据**：TCP会丢弃重复的数据。

- **应答机制**：当TCP收到TCP另一端发送来的数据，它将发送一个确认。

  > 这个确认信息是推迟几分之一秒后发送的。

- **超时重传：**当TCP一个段发出后，它将启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重传这个报文段。

- **流量控制：**TCP连接的每一方都设有一个固定大小的缓冲空间。TCP的接收端只允许发送端发送接收端的缓冲区能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出。

  > TCP使用的流量控制协议是可变大小的滑动窗口协议。

## 客户端不断进行请求连接会怎么样？DDos(Distributed Denial of Service)攻击是怎么回事？

服务端会为每个请求建立一个连接，并向其发送确认报文，然后等待用户确认。

### DDos攻击

- 客户端向服务端发送请求连接数据包
- 服务端向客户端发送确认数据包
- 客户端不断向服务端发送确认数据包，服务器一直等待来自客户端的确认。

### DDos预防（没有彻底根治的办法，除非不使用TCP）

- 限制同时打开SYN半连接的数目
- 缩短SYN半连接的Time out时间
- 关闭不必要的服务

## GET与POST

### 区别

GET与POST是我们常用的两种HTTP Method，二者之间的区别主要包括以下五方面：

1. 从功能上，GET一般用来从服务器获取资源，POST一般用来更新服务器上的资源

2. 从REST服务角度来说，

   - GET是幂等的，即读取同一个资源，总是得到相同的数据，
   - POST不是幂等的，因为每次请求对资源的改变是不相同的。

   进一步地，

   - GET不会改变服务器上地资源，
   - POST会对服务器上地资源进行改变。

3. 从请求参数形式上看，

   - GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的 请求头 中，以`?`分割URL和传输数据，参数之间以`&`相连。特别地，如果数据是英文字母或数字，原样发送；否则，会将其编码为 `application/x-www-form-urlencoded MIME` 字符串（如果是空格，转换为`+`，如果是中文/其他字符，则直接把字符串用`BASE64`加密，得出如：`%E4%BD%A0%E5%A5%BD`，其中`％XX`中的`XX`为该符号以16进制表示的ASCII）
   - 而POST请求会把提交的数据放置在HTTP请求报文的`请求体`中

4. 就安全性而言，POST安全性要比GET更高，因为

   - GET请求将数据明文出现在URL上，
   - 而POST请求参数则被包装到请求体中，相对更安全。

5. 从请求的大小看，

   - GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小
   - 而POST请求则没有大小限制。

### GET请求中URL编码的意义

在GET请求中会对URL中非西文字符进行编码，这样做的目的就是为了 **避免歧义**。看下面的例子，

　　针对`name1=value1&name2=value2`的例子，我们来谈一下数据从客户端到服务端的解析过程。首先，上述字符串在计算机中用ASCII码表示为：

```
   6E616D6531 3D 76616C756531 26 6E616D6532 3D 76616C756532
   6E616D6531：name1 
   3D：= 
   76616C756531：value1 
   26：&
   6E616D6532：name2 
   3D：= 
   76616C756532：value2 
```

服务端在接收到该数据后就可以遍历该字节流，一个字节一个字节的吃，当吃到`3D`这字节后，服务端就知道前面吃得字节表示一个key，再往后吃，如果遇到`26`，说明从刚才吃的`3D`到`26`子节之间的是上一个key的value，以此类推就可以解析出客户端传过来的参数。

　　现在考虑这样一个问题，如果我们的参数值中就包含`=`或`&`这种特殊字符的时候该怎么办？比如，`name1=value1`，其中value1的值是`va&lu=e1`字符串，那么实际在传输过程中就会变成这样`name1=va&lu=e1`。这样，我们的本意是只有一个键值对，但是服务端却会解析成两个键值对，这样就产生了歧义。

　　那么，如何解决上述问题带来的歧义呢？解决的办法就是对参数进行URL编码：例如，我们对上述会产生歧义的字符进行URL编码后结果：`name1=va%26lu%3D`，这样服务端会把紧跟在`%`后的字节当成普通的字节，就是不会把它当成各个参数或键值对的分隔符。

## TCP与UDP的区别

​	TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议均属于传输层协议，它们之间的区别包括：

- TCP是面向连接的，UDP是无连接的
- TCP是可靠的，UDP是不可靠的
- TCP仅支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式
- TCP是面向字节流的，UDP是面向报文的
- TCP拥有拥塞控制机制，UDP没有拥塞控制，适合媒体通信
- TCP首部开销（20字节）比UDP首部开销（8字节）要大

## TCP的拥塞控制

​	计算机网络中的带宽、交换结点中的缓存及处理机等都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况就叫做拥塞。拥塞控制就是 <u>防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。</u>**注意，拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。**

拥塞控制的方法主要有以下四种：

1. **慢启动：**不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小;

2. **拥塞避免：**拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口`cwnd`加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。

3. **快速重传：**快重传要求接收方在收到一个 **失序的报文段** 后就立即发出 **重复确认**（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。

   ![快速重传](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f61b5419-c94a-4df1-8d4d-aed9ae8cc6d5.png)

4. **快恢复：**快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行`乘法减小`算法，把`ssthresh`门限减半，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将`cwnd`设置为`ssthresh`的大小，然后执行拥塞避免算法。

   ![cwnd](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/910f613f-514f-4534-87dd-9b4699d59d31.png)

   ## 从输入网址到获得页面的过程

   1. 浏览器查询 DNS，获取域名对应的IP地址:具体过程包括

      - 浏览器搜索自身的DNS缓存、
      - 搜索操作系统的DNS缓存、
      - 读取本地的Host文件
      - 和向本地DNS服务器进行查询等。
        - 对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；
        - 如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。
        - 如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；

      ![DNS解析过程](https://images2015.cnblogs.com/blog/949433/201610/949433-20161003112743457-1580560271.png)

   2. 浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手

   3. TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求

   4. 服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器

      ![HTTP请求与响应](https://images2015.cnblogs.com/blog/949433/201610/949433-20161003112956551-47764667.png)

   5. 浏览器解析并渲染视图，若遇到对`js`文件、`css`文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源

   6. 浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。

## Session、Cookie与Application

Cookie和Session都是客户端与服务器之间保持状态的解决方案，具体来说，

- Cookie机制采用的是在客户端保持状态的方案，
- 而Session机制采用的是在服务器端保持状态的方案。

### Cookie

Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie，而客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器，服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。

### Session

同样地，会话状态也可以保存在服务器端。客户端请求服务器，如果服务器记录该用户状态，就获取Session来保存状态，这时，如果服务器已经为此客户端创建过session，服务器就按照`sessionid`把这个session检索出来使用；如果客户端请求不包含`sessionid`，则为此客户端创建一个session并且生成一个与此session相关联的`sessionid`，并将这个`sessionid`在本次响应中返回给客户端保存。保存这个`sessionid`的方式可以采用 cookie机制 ，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器；若浏览器禁用Cookie的话，可以通过 URL重写机制 将`sessionid`传回服务器。

### Session与Cookie对比

- **实现机制：**Session的实现常常依赖于Cookie机制，通过Cookie机制回传`SessionID`
- **大小限制：**Cookie有大小限制并且浏览器对每个站点也有Cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关
- **安全性：**Cookie存在安全隐患，通过拦截或本地文件找得到Cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全
- **服务器资源消耗：**Session是保存在服务器端上会存在一段时间才会消失，如果Session过多会增加服务器的压力。

### Application

Application（Java Web中的`ServletContext`）：与一个Web应用程序相对应，为应用程序提供了一个全局的状态，所有客户都可以使用该状态。

## OSI网络体系结构与TCP/IP协议模型

![网络体系结构](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0fa6c237-a909-4e2a-a771-2c5485cd8ce0.png)

TCP/IP：

![TCP/IP](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/48d79be8-085b-4862-8a9d-18402eb93b31.png)

1. 物理层

   参考模型的最低层，也是OSI模型的第一层，实现了相邻计算机节点之间比特流的透明传送，并尽可能地屏蔽掉具体传输介质和物理设备的差异，使其上层(数据链路层)不必关心网络的具体传输介质。

2. 数据链路层（Data Link Layer）

   接收来自物理层的位流形式的数据，并封装成`帧`，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层在物理层提供的比特流的基础上，通过`差错控制`、`流量控制`方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。

   ![链路层](https://images2015.cnblogs.com/blog/949433/201610/949433-20161003113343739-692523291.png)

3. 网络层

   将网络地址翻译成对应的物理地址，并通过`路由选择算法`为分组通过通信子网选择最适当的路径。

   ![网络层](https://images2015.cnblogs.com/blog/949433/201610/949433-20161003113244364-1528707344.png)

4. 传输层（Transport Layer）

   在源端与目的端之间提供可靠的透明数据传输，使上层服务用户不必关系通信子网的实现细节。在协议栈中，传输层位于网络层之上，传输层协议为不同主机上运行的进程提供逻辑通信，而网络层协议为不同主机提供逻辑通信，如下图所示。

5. 会话层（Session Layer）

   会话层是OSI模型的第五层，是用户应用程序和网络之间的接口，负责在网络中的两节点之间建立、维持和终止通信。

6. 表示层（Presentation Layer）：数据的编码，压缩和解压缩，数据的加密和解密

   表示层是OSI模型的第六层，它对来自应用层的命令和数据进行解释，以确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。

7. 应用层（Application Layer）：为用户的应用进程提供网络通信服务

   - DNS解析过程

   ![DNS](https://images2015.cnblogs.com/blog/949433/201610/949433-20161003112743457-1580560271.png)

   - HTTP请求与响应

   ![HTTP](https://images2015.cnblogs.com/blog/949433/201610/949433-20161003112956551-47764667.png)

   ​

## TCP和UDP分别对应的常见应用层协议

### TCP对应的应用层协议

- **FTP：**定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。
- **Telnet：**它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。
- **SMTP：**定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。
- **POP3：**它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Foxmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮箱来收信）。
- **HTTP：**从Web服务器传输超文本到本地浏览器的传送协议。

|      协议      |                    全称                    |        默认端口         |
| :----------: | :--------------------------------------: | :-----------------: |
| HTTP （ 用的最多） |   HyperText Transfer Protocol（超文本传输协议）   |         80          |
|     FTP      |     File Transfer Protocol (文件传输协议)      | 20用于传输数据，21用于传输控制信息 |
|     SMTP     | Simple Mail Transfer Protocol (简单邮件传输协议) |         25          |
|    Telnet    |     Teletype over the Network (网络电传)     |         23          |
|     SSH      |               Secure Shell               |         22          |

### UDP对应的应用层协议

- **DNS：**用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。
- **SNMP：**简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。
- **TFTP(Travel File Transfer Protocol):**简单文件传输协议，该协议在熟知端口69上使用UDP服务。

|  协议  |                    全称                    |               默认端口               |
| :--: | :--------------------------------------: | :------------------------------: |
| DNS  |        Domain Name Service (域名服务)        |                53                |
| TFTP | Trivial File Transfer Protocol (简单文件传输协议) |                69                |
| SNMP | Simple Network Management Protocol (简单网络管理协议) | 通过UDP端口161接收，只有Trap信息采用UDP端口162。 |
| NTP  |      Network Time Protocol (网络时间协议)      |               123                |

## IP地址

1. **网络地址：**

   IP地址由网络号（包括子网号）和主机号组成，网络地址的主机号为全0，网络地址代表着整个网络。

2. **广播地址：**

   广播地址通常称为直接广播地址，是为了区分受限广播地址。

   广播地址与网络地址的主机号正好相反，广播地址中，主机号为全1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。

3. **组播地址：**

   D类地址就是组播地址。先回忆下A，B，C，D类地址吧：

   - A类地址以0开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255
   - B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255
   - C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255
   - D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）
   - E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。

   **注：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。**

4. **255.255.255.255：**

   该IP地址指的是受限的广播地址。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能收到该数据报；若发送受限广播数据报，则不能收到。

   **注：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。**

5. **0.0.0.0：**

   常用于寻找自己的IP地址，例如在我们的RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。

6. **回环地址：**

   127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是127.0.0.1。

7. **A、B、C类私有地址：**

   私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。

   - A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255
   - B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255
   - C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255

## 子网掩码及网络划分

### 子网掩码

子网掩码是标志两个IP地址是否同属于一个子网的，也是32位二进制地址，其每一个为1代表该位是网络位，为0代表主机位。它和IP地址一样也是使用点式十进制来表示的。如果两个IP地址在子网掩码的按位与的计算下所得结果相同，即表明它们共属于同一子网中。

### 子网掩码的计算

对于无须再划分成子网的IP地址来说，其子网掩码非常简单，即按照其定义即可写出：如某B类IP地址为 10.12.3.0，无须再分割子网，则该IP地址的子网掩码255.255.0.0。如果它是一个C类地址，则其子网掩码为 255.255.255.0。其它类推，不再详述。下面我们关键要介绍的是一个IP地址，还需要将其高位主机位再作为划分出的子网网络号，剩下的是每个子网的主机号，这时该如何进行每个子网的掩码计算。

　　下面总结一下有关子网掩码和网络划分常见的面试考题：

1. **利用子网数来计算**

   在求子网掩码之前必须先搞清楚要划分的子网数目，以及每个子网内的所需主机数目。

   - 将子网数目转化为二进制来表示

     如欲将B类IP地址168.195.0.0划分成27个子网：27=11011；

   - 取得该二进制的位数，为N

     该二进制为五位数，N = 5

   - 取得该IP地址的类子网掩码，将其主机地址部分的的前N位置1即得出该IP地址划分子网的子网掩码

     将B类地址的子网掩码255.255.0.0的主机地址前5位置 1，得到 255.255.248.0

2. **利用主机数来计算**

   如欲将B类IP地址168.195.0.0划分成若干子网，每个子网内有主机700台：

   - 将主机数目转化为二进制来表示；

     700=1010111100；

   - 如果主机数小于或等于254（注意去掉保留的两个IP地址），则取得该主机的二进制位数，为N，这里肯定 `N<8`。如果大于254，则 `N>8`，这就是说主机地址将占据不止8位；

     该二进制为十位数，N=10；

   - 使用255.255.255.255来将该类IP地址的主机地址位数全部置1，然后从后向前的将N位全部置为 0，即为子网掩码值。

     将该B类地址的子网掩码255.255.0.0的主机地址全部置1，得到255.255.255.255，然后再从后向前将后 10位置0,即为：11111111.11111111.11111100.00000000，即255.255.252.0。这就是该欲划分成主机为700台的B类IP地址 168.195.0.0的子网掩码。

3. **还有一种题型，要你根据每个网络的主机数量进行子网地址的规划和计算子网掩码。这也可按上述原则进行计算。**

   比如一个子网有10台主机，那么对于这个子网需要的IP地址是：

   10＋1＋1＋1＝13

   **注意：加的第一个1是指这个网络连接时所需的网关地址，接着的两个1分别是指网络地址和广播地址。**

   因为13小于16（16等于2的4次方），所以主机位为4位。而256－16＝240，所以该子网掩码为255.255.255.240。

   如果一个子网有14台主机，不少人常犯的错误是：依然分配具有16个地址空间的子网，而忘记了给网关分配地址。这样就错误了，因为14＋1＋1＋1＝17，17大于16，所以我们只能分配具有32个地址（32等于2的5次方）空间的子网。这时子网掩码为：255.255.255.224。

## ARP/RARP协议

### ARP

**地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。**

**ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。**

**ARP协议工作流程：**

1. 首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。
2. 当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，
   - 如果有，则直接发送数据，
   - 如果没有，就向本网段的所有主机发送ARP 数据包，该数据包包括的内容有：
     - 源主机IP地址，
     - 源主机MAC地址，
     - 目的主机的IP地址。
3. 当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP 地址是否是自己的IP地址，
   - 如果不是，则忽略该数据包，
   - 如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，
     - 如果已经存在，则覆盖，
   - 然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。
4. 源主机收到ARP响应包后，将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。
   - 如果源主机一直没有收到ARP响应数据包，表示ARP 查询失败。

### RARP

**逆地址解析协议，即RARP，功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址**

**RARP协议工作流程：**

1. 给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；
2. 本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；
   - 如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；
   - 如果不存在，RARP服务器对此不做任何的响应；
3. 源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；
   - 如果一直没有收到RARP服务器的响应信息，表示初始化失败。

## HTTP（超文本传输协议）

**HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。**HTTP是一个基于TCP/IP通信协议来传递数据，默认端口号为80。

### HTTP工作原理

HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。

1. **客户端连接到Web服务器**

   一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，http://www.oakcms.cn。

2. **发送HTTP请求**

   通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。

3. **服务器接受请求并返回HTTP响应**

   Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。

4. **释放连接TCP连接**

   若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;

5. **客户端浏览器解析HTML内容**

   客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。

### HTTP消息结构

HTTP是基于客户端/服务端（C/S）的架构模型。客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，请求报文的一般格式

![HTTP消息结构](https://images2018.cnblogs.com/blog/1361655/201804/1361655-20180413120416720-1194570336.png)

HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。

![HTTP相应结构](https://images2018.cnblogs.com/blog/1361655/201804/1361655-20180413120441690-412327236.jpg)

### HTTP常见状态码

**重点：200, 304, 403, 404, 500**

- 2开头

  ##### 2xx (成功)表示成功处理了请求的状态代码

  ```
  200 (成功) 服务器已成功处理了请求。 通常。
  ```

- 3开头

  ##### 3xx (重定向) 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。

  ```
  304 (未修改) 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。
  ```

- 4开头

  ##### 4xx(请求错误) 这些状态代码表示请求可能出错，妨碍了服务器的处理

  ```
  400 (错误请求) 服务器不理解请求的语法。
   
  403 (禁止) 服务器拒绝请求。

  404 (未找到) 服务器找不到请求的网页。
  ```

- 5开头

  ##### 5xx(服务器错误)这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错

  ```
  500 (服务器内部错误) 服务器遇到错误，无法完成请求。

  501 (尚未实施) 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。

  502 (错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。

  503 (服务不可用) 服务器目前无法使用(由于超载或停机维护)。 通常，这只是暂时状态。

  504 (网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求。

  505 (HTTP 版本不受支持) 服务器不支持请求中所用的 HTTP 协议版本。
  ```


