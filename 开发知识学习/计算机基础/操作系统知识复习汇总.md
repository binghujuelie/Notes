# 操作系统面试知识复习汇总

> 转载声明：
>
> 本文原创作者：
>
> ​	[少年T的奇幻漂流](https://www.nowcoder.com/profile/220525776) 
>
> ​	[祥哥的说](https://sunzhaoxiang.blog.csdn.net/?type=blog)
> 作者博客地址：
>
> ​	<https://blog.nowcoder.net/n/49211c67aaaa49eb8842f7e979c79498> 
>
> ​	<https://blog.csdn.net/qq_39207948/article/details/80677811>



[TOC]

- [ ] 分段分页
- [ ] 调度算法
- [ ] 银行家算法
- [ ] 虚拟设备

## 什么是线程与进程，有何区别？进程与程序的区别？

### 进程与线程

- 线程是进程的一个实体，一个进程可以有多个线程。
- 一个没有线程的进程可以看作是单线程的，同样线程也经常被看做是一种轻量级进程。
- 进程可以不依赖于线程而单独存在，而线程则不然。
- 进程是并发程序在一个数据集合上的一次执行过程，进程是系统进行资源分配和调度的独立单位。
- 与进程的控制表PCB类似，线程也有自己的控制表TCB，但是TCB中所保存的线程状态比PCB表少得多。
- 线程自己不用有任何系统资源，但是可以访问其隶属进程的所有资源。由于线程基本不拥有系统资源，所以在进行切换时，线程切换的开销远远小于进程。
- **进程的作用与定义：**为了提高CPU的执行效率，避免等待造成的CPU空转以及其他计算机硬件资源的浪费而提出。
- **线程的引入：**创建一个进程要花费较大的系统开销和占用较多的资源。除外，不同的用户子进程在执行的时候涉及到进程上下文切换，上下文切换是一个复杂的过程。所以，为了减少进程切换和创建的开销，提高执行效率和节省资源，人们在操作系统中引入了线程的概念。
- **线程的作用：**操作系统中引入线程的目的，则是为了减少进程并发执行过程中所付出的时空开销，使操作系统能很好的并发执行。
- 进程process定义了一个**执行环境**，包括它自己私有的地址空间、一个句柄表，以及一个安全环境；线程则是一个**控制流**，有他自己的调用栈call stack，记录了它的执行历史。
- **线程的组成：**
  - **线程的内核对象**，操作系统用它来对线程实施管理。内核对象也是系统用来存放线程统计信息的地方。
  - **线程堆栈**，它用于维护线程在执行代码时需要的所有参数和局部变量。当创建线程时，系统创建一个线程内核对象。该线程内核对象不是线程本身，而是操作系统用来管理线程的较小的数据结构。可以将线程内核对象视为由关于线程的统计信息组成的一个小型数据结构。

| 比较项  | 进程                                       | 线程                                       |
| :--- | :--------------------------------------- | :--------------------------------------- |
| 活泼性  | 不活泼（只作为线程的容器）                            | 活泼                                       |
| 地址空间 | 系统赋予的独立的**虚拟地址空间**（对于32位进程来说，这个地址空间是4GB） | 在进程的地址空间执行代码。线程只有一个内核对象和一个堆栈，保留的记录很少，因此需要的内存也很少。 |
| 调度   | 仅是资源分配的基本单位                              | 独立调度、分派的基本单位                             |
| 并发性  | 仅进程间并发（传统OS）                             | 进程间、线程间并发                                |
| 拥有资源 | 资源拥有的基本单位                                | 基本不拥有资源                                  |
| 系统开销 | 创建、撤销、切换开销大                              | 仅保存少量寄存器内容，开销小。                          |



### 进程与程序

- 进程与应用程序的区别在于应用程序作为一个**静态文件**存储在计算机系统的硬盘等存储空间中，而进程则是处于**动态条件**下由操作系统维护的**系统资源管理实体。**

|      | 定义                                       | 使用系统运行资源情况                               |
| ---- | ---------------------------------------- | ---------------------------------------- |
| 程序   | 计算机指令的集合，以文件形式存储在磁盘上。程序是**静态实体(Passive Entity)**，在多道程序系统中，它是不能独立运行的有，更不能与其他程序并发执行。 | 不使用【程序不能申请系统资源，不能被系统调度，也不能作为独立运行的单位。因此，他不占用系统的运行资源。】 |
| 进程   | 通常被定义为一个正在运行的程序的实例，是一个程序在其自身的地址空间中的一次执行活动。定义：进程是程序的实体（包括：程序段、相关数据段、进程控制块PCB）的运行过程，是系统进行资源分配和调度的一个独立单位。 | 使用【进程是资源申请、调度和独立运行的单位。因此，它使用系统中的运行资源。】   |

## 线程同步的方式有哪些

- **互斥对象：**采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。
- **信号量：**它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。
- **信号（事件）：**通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。

## Windows下的内存管理方法

- **虚拟内存：**最适合用来管理**大型对象或者结构数组**
- **内存映射文件：**最适合用来管理**大型数据流**（通常来自文件）以及在单个计算机上运行**多个进程之间共享数据**
- **内存堆栈：**最适合用来管理**大量的小对象**。

## 中断和轮询

- 对I/O设备的程序轮询的方式，是早期的计算机系统对I/O设备的一种管理方式。

  它定时对各种设备轮流询问一遍有无处理要求。轮流询问之后，有要求的，则加以处理。

  在处理I/O设备的要求之后，处理机返回继续工作。

  尽管轮询需要时间，但轮询要比I/O设备的速度要快得多，所以一般不会发生不能及时处理的问题。当然，再快的处理机，能处理的输入输出设备的数量也是有一定限度的。而且，程序轮询毕竟占据了CPU相当一部分处理时间，因此，程序**轮询**是一种**效率较低**的方式，在现代计算机系统中已很少应用。

- 程序中断通常简称**中断**，是指CPU在正常运行程序的过程中，由于预先安排或发生了各种随机的内部或外部事件，使CPU中断正在运行的程序，而转到为响应的服务程序去处理。

- 轮询——效率低，等待时间很长，CPU利用率不高。

  中断——容易遗漏一些问题，CPU利用率高。

## 什么是临界区？如何解决冲突？

- 每个进程中访问临界资源的那段程序称为临界区，每次只准许一个进程进入临界区，进入后不允许其他进程进入。
- 解决思想：
  1. 如果有若干进程要求进入空闲的临界区，**一次仅允许一个进程进入**；
  2. 任何时候，**处于临界区内的进程不可多于一个**。如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待；
  3. 进入临界区的进程要在**有限时间内退出**，以便其它进程能及时进入自己的临界区；
  4. 如果进程不能进入自己的临界区，则应**让出CPU**，避免进程出现“忙等”现象。

## 分段和分页

### 段式存储管理

- 段式存储管理**是一种符合用户视角的内存分配管理方案。在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个**二维地址空间**，相互独立，互不干扰。段式管理的优点是：**没有内碎片**（因为段大小可变，改变段大小来消除内碎片）。但**段换入换出时，会产生外碎片**（比如4k的段换5k的段，会产生1k的外碎片）

###页式存储管理

- **页式存储管理**方案是一种用户视角内存与物理内存相分离的内存分配管理方案。在页式存储管理中，将程序的**逻辑地址划分为固定大小的页（page）**，而**物理内存**划分为同样大小的**帧**，程序加载时，可以将任意一页放入内存中任意一个帧，这些帧不必连续，从而实现了离散分离。页式存储管理的优点是：**没有外碎片**（因为页的大小固定），但**会产生内碎片**（一个页可能填充不满）。

### 二者的不同：

- **目的不同：**分页是由于系统管理的需要而不是用户的需要，它是**信息的物理单位**；分段的目的是为了能更好地满足用户的需要，它是**信息的逻辑单位**，它含有一组其**意义相对完整**的信息；
- **大小不同：**页的**大小固定**且由系统决定，而段的长度却**不固定**，由其所完成的功能决定；
- **地址空间不同：** 段向用户提供**二维地址空间**；页向用户提供的是**一维地址空间**；
- **信息共享：**段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；
- **内存碎片：**页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。

## 保持进程同步的方法

进程间同步的主要方法有**原子操作、信号量机制、自旋锁、管程、会合、分布式系统**等。

## Linux中的常用命令

| 操作     | 命令    | 举例                  |
| ------ | ----- | ------------------- |
| 显示文件目录 | ls    | ls                  |
| 改变当前目录 | cd    | cd /home            |
| 建立子目录  | mkdir | mkdir newDir        |
| 删除子目录  | rmdir | rmdir /bhjl/newDir  |
| 删除文件   | rm    | rm /dosth.bat       |
| 文件复制   | cp    | cp /dosth /copyFile |
| 获取帮助信息 | man   | man ls              |
| 显示文件内容 | less  | less file.txt       |
| 重定向与管道 | type  | type readme>>direct |

注：`type readme>>direct`是将文件readme的内容追加到文direct中

## makefile文件的作用

工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中。makefile**定义了一系列的规则**来指定哪些文件需要先编译，哪些文件需要后**编译**，哪些文件需要重新编译，甚至于进行更复杂的功能操作。

##  什么是中断？中断时CPU做什么工作？

中断是指在计算机执行期间，系统内发生任何非寻常的或非预期的急需处理事件，使得CPU**暂时中断**当前正在执行的程序而转去执行相应的事件处理程序。待**处理完毕后又返回**原来被中断处继续执行或调度新的进程执行的过程。

## 你知道操作系统的内容分为几块吗？什么叫做虚拟内存？他和主存的关系如何？内存管理属于操作系统的内容吗？

操作系统的主要组成部分：**进程和线程的管理，存储管理，设备管理，文件管理**。

虚拟内存是一些系统页文件，存放在磁盘上，每个系统页文件大小为4K，物理内存也被分页，每个页大小也为4K，这样虚拟页文件和物理内存页就可以对应，实际上**虚拟内存就是用于物理内存的临时存放的磁盘空间**。页文件就是内存页，物理内存中每页叫物理页，磁盘上的页文件叫虚拟页，物理页+虚拟页就是系统所有使用的页文件的总和。

## 什么是缓冲区溢出？有什么危害？其原因是什么？

缓冲区溢出是指当计算机向缓冲区内填充数据时**超过了缓冲区本身的容量**，溢出的数据覆盖在合法数据上。造成缓冲区溢出的主原因是程序中**没有仔细检查用户输入的参数**。

危害有以下两点：

- **程序崩溃**，导致拒绝服务
- 跳转并且**执行一段恶意代码**

## 什么是死锁？其条件是什么？怎样避免死锁？

### 死锁的概念

- 在两个或多个并发进程中，如果每个进程持有某种资源而又都等待别的进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗地讲，就是两个或多个进程被**无限期地阻塞、相互等待**的一种状态。


- 死锁产生的原因主要是： 系统资源不足； 进程推进顺序非法。

### 产生死锁的必要条件

1. **互斥（mutual-exclusion）**，一个资源每次只能被一个进程使用；
2. **不可抢占（no-preemption）**，进程已获取的资源，在未使用完之前，不能强行剥夺；
3. **占有并等待（hold-and-wait）**，一个进程因请求资源而阻塞时，对已获得的资源保持不放；
4. **环形等待（circular-wait）**，若干进程之间形成一种首尾相接的循环等待资源的关系。

这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

### 死锁的解除与预防

- 理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。


- 死锁的处理策略：**鸵鸟策略、预防策略、避免策略、检测与恢复策略**。

## 进程间的通信是如何实现的？

### 进程间通信的方式

- **管道：**有命名管道和非命名管道之分，**非命名管道**只能用于**父子进程通讯**，**命名管道**可用于**非父子进程**，命名管道就是FIFO，管道是**先进先出**的通讯方式。FIFO是一种先进先出的队列。它类似于一个管道，只允许数据的单向流动。每个FIFO都有一个名字，允许不相关的进程访问同一个FIFO，因此也成为命名管道。
- **消息队列：**是用于两个进程之间的通讯，首先在一个进程中创建一个消息队列，然后再往消息队列中写数据，而另一个进程则从那个消息队列中取数据。需要注意的是，消息队列是用**创建文件的方式建立的**，如果一个进程向某个消息队列中写入了数据之后，另一个进程并没有取出数据，即使向消息队列中写数据的进程已经结束，保存在消息队列中的数据并没有消失，也就是说下次再从这个消息队列读数据的时候，就是上次的数据！！！
- **信号量：**不能传递复杂消息，只能**用来同步**
- **共享内存：**只要首先创建一个共享内存区，其它进程按照一定的步骤就能访问到这个共享内存区中的数据，当然可读可写；

### 几种方式的比较

- **管道：**速度慢、容量有限
- **消息队列：**容量受系统容量限制，且注意第一次读的时候要考虑上一次没有读完的数据。
- **信号量：**不能传递复杂消息，只能用来同步。
- **共享内存区：**能够很容易控制容量，速度快，但要保持同步。

进程通信，是指进程之间的信息交换（信息量少则一个状态或数值，多者则是成千上万个字节）。因此，对于用信号量进行的进程间的互斥和同步，由于其所交换的信息量少而被归结为低级通信。

所谓高级进程通信指：用户可以利用操作系统所提供的一组通信命令传送大量数据的一种通信方式。操作系统隐藏了进程通信的实现细节。或者说，通信过程对用户是不透明的。

### 高级通信机制可归结为三大类

1. **共享存储器系统（存储器中划分的共享存储区）：**实际操作中对应的是**“剪贴板”**（剪贴板实际上是系统维护管理的一块内存区域）的通信方式，比如举例如下：word进程按下ctrl+c，在ppt进程按下ctrl+v，即完成了word进程和ppt进程之间的通信，复制时将数据放入到剪贴板，粘贴时从剪贴板中取出数据，然后显示在ppt窗口上。
2. **消息传递系统（进程间的数据交换以消息(message)为单位）：**当今最流行的微内核操作系统中，微内核与服务器之间的通信，无一例外地都采用了消息传递机制。应用举例：**邮槽**（MailSlot）是基于广播通信体系设计出来的，它采用无连接的不可靠的数据传输。邮槽是一种单向通信机制，创建邮槽的服务器进程读取数据，打开邮槽的客户机进程写入数据。
3. **管道通信系统（管道即：连接读写进程以实现他们之间通信的共享文件（pipe文件，类似先进先出的队列，由一个进程写，另一进程读））：**实际操作中，管道分为：匿名管道、命名管道。匿名管道是一个未命名的、单向管道，通过父进程和一个子进程之间传输数据。**匿名管道**只能实现**本地**机器上两个进程之间的通信，而不能实现跨网络的通信。**命名管道**不仅可以在本机上实现两个进程间的通信，还可以**跨网络**实现两个进程间的通信。

|                                | 同一机器两个进程间通信 | 跨网络通信 |
| ------------------------------ | ----------- | ----- |
| 剪贴板Clipboard                   | 可以          | 不可以   |
| 匿名管道Pipe                       | 可以          | 不可以   |
| 命名管道（点对点单一通信，数据量可以较大）Namedpipe | 可以          | 可以    |
| 邮槽（一对多，数据量较小，424字节以下）Mailslot  | 可以          | 可以    |

## 进程有哪几种状态？

- 就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源
- 运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数
- 阻塞状态： 进程等待某种条件，在条件满足之前无法执行 

## 操作系统中进程调度策略有哪几种？

### FCFS(先来先服务)：

​	**优先级**，**时间片**轮转，**多级反馈**

### FCFS(先来先服务：队列实现，非抢占的)：

​	先请求CPU的进程先分配到CPU

### SJF(最短作业优先调度算法)：

​	平均等待时间最短，但难以知道下一个CPU区间长度

### 优先级调度算法(可以是抢占的，也可以是非抢占的)：

​	**优先级越高越先分配到CPU**，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；解决方案：老化

### 时间片轮转调度算法(可抢占的)：

​	队列中**没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。**如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。

### 多级队列调度算法：

​	将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。

### 多级反馈队列调度算法：

​	与多级队列调度算法相比，其**允许进程在队列之间移动**：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。

### ThreadLocal与其他同步机制的比较

- Threadlocal和其他所有的同步机制都是为了解决多线程中的对同一变量的访问冲突
- 在普通的同步机制中，是通过对对象加锁来实现多个线程对同一变量的安全访问的。这时该变量是多个线程共享的，使用这种同步机制需要很细致的分析在什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放该对象的锁等等。**所有这些都是因为多个线程共享了该资源造成的。**
- Threadlocal就从另一个角度来解决多线程的并发访问，Threadlocal会**为每一个线程维护一个和该线程绑定的变量副本，从而隔离了多个线程的数据共享**，每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。
- ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。

**【总结】：**当然ThreadLocal并不能替代同步机制，两者面向的问题领域不同。同步机制是为了同步多个线程对相同资源的并发访问，是为了多个线程之间进行通信的有效方式；**而ThreadLocal是隔离多个线程的数据共享，从根本上就不在多个线程之间共享资源（变量）**，这样当然不需要对多个线程进行同步了。所以，**如果你需要进行多个线程之间进行通信，则使用同步机制；如果需要隔离多个线程之间的共享冲突，可以使用ThreadLocal**，这将极大地简化你的程序，使程序更加易读、简洁。

## 局部性原理

- **时间**上的局部性：**最近被访问的页**在不久的将来还会被访问；
- **空间上的局部性**：内存中被访问的页**周围的页**也很可能被访问。

## 缺页中断：FIFO、LRU、OPT三种置换算法

### 缺页中断

在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存时，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：

  　　1. 保护CPU现场
  　　2. 分析中断原因
  　　3. 转入缺页中断处理程序进行处理
  　　4. 恢复CPU现场，继续执行

但是缺页中断时由于所要访问的页面不存在与内存时，有硬件所产生的一种特殊的中断，因此，与一般的中断存在**区别**：

   　　1. 在指令执行期间产生和处理缺页中断信号
   　　2. 一条指令在执行期间，可能产生多次缺页中断
   　　3. 缺页中断返回时，执行产生中断的那一条指令，而一般的中断返回时，执行下一条指令

### 页面置换算法

进程运行过程中，如果发生缺页中断，而此时内存中有没有空闲的物理块是，为了能够把所缺的页面装入内存，系统必须从内存中选择一页调出到磁盘的对换区。但此时应该把那个页面换出，则需要根据一定的**页面置换算法**（Page Replacement Algorithm）来确定。

#### 最佳置换（Optimal，OPT）

- **基本思想**

  置换以后不再被访问，或者在将来最迟才会被访问的页面，缺页中断率最低。但是该算法需要依据以后各页的使用情况，而当一个进程还未运行完成时，很难估计哪一个页面是以后不再使用或在最长时间以后才会用到的页面。所以**该算法是不能实现的**。但该算法仍然有意义，作为衡量其他算法优劣的一个标准。

- **算例**

  采用固定分配局部置换的策略，假定系统为某进程在内存中分配了 3 个物理块，页面访问顺序为`2、3、2、1、5、2、4、5、3、2、5、2`假定系统未采用预调页策略，即未事先调入任何页面。进程运行时，一次将`2、3、1`三个页面调入内存，发生 3 次缺页中断。当第一次访问页面`5`时，产生第4次缺页中断，根据OPT算法，淘汰页面`1`，因为它在以后不会在使用了；第 5 次缺页中断时，淘汰页面`2`，因为它在`5、3、2`三个页面中，是在将来最迟才会被页面访问的页面。以此类推：
  注意：第 4 次中断时将最后不会访问的`1`剔除，将最后才访问的`3`放入最下面的内存块中，以后的调度过程中，最后不会访问或最后才被访问的页面总是放在最下面的内存块中。内存块从上到下依次存放最先访问的页面。
  中断次数为6，缺页中断率为 6/12*100% = 50%。

  | P:   | 2    | 3    | 2    | 1    | 5    | 2    | 4    | 5    | 3    | 2    | 5    | 2    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | M=3  | 2    | 2    | 2    | 2    | 2    | 5    | 5    | 3    | 5    | 5    | 2    | 2    |
  |      |      | 3    | 3    | 3    | 5    | 3    | 3    | 5    | 4    | 2    | 5    | 5    |
  |      |      |      |      | 1    | 3    | 2    | 4    | 4    | 3    | 4    | 4    | 4    |
  | F=5  | Y    | Y    |      | Y    | Y    |      | Y    |      |      | Y    |      |      |

#### 先进先出置换（First In First Out，FIFO）

- **基本思想**

  置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后次序排列成**队列**，从队尾进入，从队首删除。但是该算法会淘汰经常访问的页面，不适应进程实际运行的规律，目前已经**很少使用**。

- **算例**

  仍然以OPT算例为例子

  中断次数为6， 缺页中断率为9/12*100% = 75%。

| P:   | 2    | 3    | 2    | 1    | 5    | 2    | 4    | 5    | 3    | 2    | 5    | 2    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| M=3  | 2    | 3    | 3    | 1    | 5    | 2    | 4    | 4    | 3    | 3    | 5    | 2    |
|      |      | 2    | 2    | 3    | 1    | 5    | 2    | 2    | 4    | 4    | 3    | 5    |
|      |      |      |      | 2    | 3    | 1    | 5    | 5    | 2    | 2    | 4    | 3    |
| F=9  | Y    | Y    |      | Y    | Y    | Y    | Y    |      | Y    |      |      | Y    |

- Belady异常

  一般来说，分配给进程的物理块越多，运行时的缺页次数应该越少，使用FIFO时，可能存在相反情况，分配4个物理块的缺页竟然比3个物理块的缺页次数还多！

  例如：进程访问顺序为`0、2、1、3、0、2、4、0、2、1、3、4`。

  M=3时，缺页中断9次。缺页中断率9/12*100% = 75%。

| P:   | 0    | 2    | 1    | 3    | 0    | 2    | 4    | 0    | 2    | 1    | 3    | 4    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| M=3  | 0    | 2    | 1    | 3    | 0    | 2    | 4    | 4    | 4    | 1    | 3    | 3    |
|      |      | 0    | 2    | 1    | 3    | 0    | 2    | 2    | 2    | 4    | 1    | 1    |
|      |      |      | 0    | 2    | 1    | 3    | 0    | 0    | 0    | 2    | 4    | 4    |
| F=9  | Y    | Y    | Y    | Y    | Y    | Y    | Y    |      |      | Y    | Y    |      |

​	Ｍ=4时，缺页中断10次。缺页中断率10/12*100% = 83.3%。

| P:   | 0    | 2    | 1    | 3    | 0    | 2    | 4    | 0    | 2    | 1    | 3    | 4    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| M=4  | 0    | 2    | 1    | 3    | 3    | 3    | 4    | 0    | 2    | 1    | 3    | 4    |
|      |      | 0    | 2    | 1    | 1    | 1    | 3    | 4    | 0    | 2    | 1    | 3    |
|      |      |      | 0    | 2    | 2    | 2    | 1    | 3    | 4    | 0    | 2    | 1    |
|      |      |      |      | 0    | 0    | 0    | 2    | 1    | 3    | 4    | 0    | 2    |
| F=10 | Y    | Y    | Y    | Y    |      |      | Y    | Y    | Y    | Y    | Y    | Y    |

#### 最近最久未使用置换算法（Least Recently Used，LRU）

- **基本思想**

  置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。

  LRU算法普偏地适用于各种类型的程序，但是系统要时时刻刻对各页的访问历史情况加以记录和更新，开销太大，因此LRU算法必须要有硬件的支持。

- **算例**

  仍然以OPT算例为例子。

  中断次数为6，缺页中断率为7/12*100% = 58.3%。

| P:   | 2    | 3    | 2    | 1    | 5    | 2    | 4    | 5    | 3    | 2    | 5    | 2    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| M=3  | 2    | 3    | 2    | 1    | 5    | 2    | 4    | 5    | 3    | 2    | 5    | 2    |
|      |      | 2    | 3    | 2    | 1    | 5    | 2    | 4    | 5    | 3    | 2    | 5    |
|      |      |      |      | 3    | 2    | 1    | 5    | 2    | 4    | 5    | 3    | 3    |
| F=7  | Y    | Y    |      | Y    | Y    |      | Y    |      | Y    | Y    |      |      |

- **堆栈实现LRU**

  系统使用特殊的堆栈来存放内存中每一个页面的页号。每当访问一页时就调整一次，即把被访问页面的页号从栈中移出再压入栈顶。因此，栈顶始终是最新被访问页面的页号，栈底始终是最近最久未被访问的页号。当发生缺页中断时，总是淘汰栈底页号所对应的页面。

## 内存颠簸

- 颠簸本质上是指**频繁的页调度**行为，具体来讲，进程发生缺页中断，这时，必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻**再次需要这个页**。因此，会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸（抖动）。
- 内存颠簸的解决策略包括：
  - 如果是因为页面替换策略失误，可以**修改替换算法**来解决这个问题；
  - 如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要**降低多道程序的数量**；
  - 否则，还剩下两个办法：**终止该进程或增加物理内存容量**。

## 虚拟内存的应用与优点

- 虚拟内存允许执行进程不必完全在内存中。虚拟内存的基本思想是：每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页(Page)，每个页都是一段连续的地址。这些页**被映射到物理内存**，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。这样，对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块(称为帧，通常页和帧大小相等)，还有一些没加载在内存中的对应在硬盘上，如图所示。<u>注意，请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。</u>
- 由图可以看出，虚拟内存实际上可以比物理内存大。当访问虚拟内存时，会访问MMU（内存管理单元）去匹配对应的物理地址（比如图5的0，1，2）。如果虚拟内存的页并不存在于物理内存中（如图5的3,4），会产生缺页中断，从磁盘中取得缺的页放入内存，如果内存已满，还会根据某种算法将磁盘中的页换出。

![虚拟内存](https://uploadfiles.nowcoder.com/images/20190723/220525776_1563877459292_F5CB0AD2C92C30DF24FC9C18034B313D)

- 虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。虚拟内存的使用可以带来以下好处：
  - **在内存中可以保留多个进程，系统并发度提高**
  - **解除了用户与内存之间的紧密约束，进程可以比内存的全部空间还大**

## 页面置换算法

- FIFO先进先出算法

​	在操作系统中经常被用到，比如作业调度（主要实现简单，很容易想到）；

- LRU（Least recently use）最近最少使用算法

​	根据使用时间到现在的长短来判断；

- LFU（Least frequently use）最少使用算法

​	根据使用次数来判断；

- OPT（Optional replacement）最优置换算法

​	理论的最优，理论；就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法。

## 线程有几种状态？进程呢？

在 Java虚拟机 中，**线程**从最初的创建到最终的消亡，要经历若干个状态：**创建(new)、就绪(runnable/start)、运行(running)、阻塞(blocked)、等待(waiting)、时间等待(time waiting) 和 消亡(dead/terminated)。**在给定的时间点上，一个线程只能处于一种状态，各状态的含义如下图所示：

- **就绪状态**：进程已获得除处理机以外的所需资源，等待分配处理机资源；
- **运行状态**：占用处理机资源运行，处于此状态的进程数小于等于CPU数；
- **阻塞状态**： 进程等待某种条件，在条件满足之前无法执行；

![线程状态示意图](https://uploadfiles.nowcoder.com/images/20190723/220525776_1563877459692_F5CB0AD2C92C30DF24FC9C18034B313D)

## 孤儿进程、僵尸进程、守护进程

**孤儿进程**：如果**父进程先退出,子进程还没退出**那么子进程将被托孤给`init`进程,这时子进程的父进程就是`init`进程(1号进程).其实还是很好理解的

**僵尸进程：**如果我们了解过Linux进程状态及转换关系,我们应该知道进程这么多状态中有一种状态是僵死状态,就是进程终止后进入僵死状态(zombie)，等待告知父进程自己终止后才能完全消失。但是如果一个进程已经终止了，但是其父进程还没有获取其状态，那么这个进程就称之为僵尸进程。僵尸进程还会消耗一定的系统资源，并且还保留一些概要信息供父进程查询子进程的状态可以提供父进程想要的信息。一旦父进程得到想要的信息，僵尸进程就会结束。

**守护进程：**同样我们需要了解一下什么是守护进程，守护进程就是在后台运行，不与任何终端关联的进程，通常情况下守护进程在系统启动时就在运行，它们以root用户或者其他特殊用户(apache和postfix)运行，并能处理一些系统级的任务。习惯上守护进程的名字通常以d结尾(sshd)，但这些不是必须的。

## 线程池问题

多线程的异步执行方式，虽然能够最大限度发挥多核计算机的计算能力，但是如果不加控制，反而会对系统造成负担。线程本身也要占用内存空间，大量的线程会占用内存资源并且可能会导致Out of Memory。即便没有这样的情况，大量的线程回收也会给GC带来很大的压力。

为了避免重复的创建线程，**线程池的出现可以让线程进行复用**。通俗点讲，当有工作来，就会向线程池拿一个线程，当工作完成后，并不是直接关闭线程，而是**将这个线程归还给线程池**供其他任务使用。

